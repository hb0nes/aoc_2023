Tabulated approach

Variables:
- Springs
- Groups

Group should only be checked for match if previous group has been checked.

Base cases:
groups.len() == 0 && !springs.contains("#")
No groups and no broken springs. No action needed.

--------------------------------------------------
Scenario 1: ??.? 2,1
--------------------------------------------------
i=0, j=0 ??.? 2,1
         ^^       -> match. That means the next group can be checked starting at index 3. In code: dp[i+groups[j]+1] += 1;
i=1, j=0 ??.? 2,1
          ^^      -> no match. only check first group.
i=2, j=0 ??.? 2,1
           ^^     -> no match. only check first group.
i=3, j=0 ??.? 2,1
            ^^    -> out of bounds for first group. Check second group because it's now possible (dp[i][j-1] > 0)
                     ^
                     if i + groups[j] > springs.len() { continue; }


      dp[0]   dp[1]   dp[2]   dp[3]   dp[4]   dp[5]   dp[6]
i=0 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 1], [1, 1] ]
i=1 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 1], [1, 1] ]
i=2 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 1], [1, 1] ]
i=3 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 1], [1, 1] ]
i=4 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 1], [1, 1] ]

Answer = 1

--------------------------------------------------
Scenario 2: ???.?? 2,1
--------------------------------------------------

INSIGHT: Every iteration: dp[i+1][j] += dp[i][j]
INSIGHT: Based on remaining groups and remaining string length, we need to continue
minimum_remaining_strings = groups.iter().sum() + groups.iter().count() - 1;
INSIGHT: if a certain i is positioned on a # and a j matches it, we should stop checking that j for other i's


i=0, j=0 ???.?? 2,1
         ^^            -> match. dp[0+2+1][0] += 1;
i=1, j=0 ???.?? 2,1
          ^^           -> match. dp[1+2+1][0] += 1;
i=2, j=0 ???.?? 2,1
           ^^          -> no match.
i=3, j=0 ???.?? 2,1
            ^^         -> skip logic
  i=3, j=1 ???.?? 2,1   -> check 2nd group because dp[3][j-1] > 0
              ^         -> no match.
i=4, j=0 ???.?? 2,1
             ^^        -> skip logic
  i=4, j=1 ???.?? 2,1
               ^        -> match. dp[4+1+1][1] += 1;
i=5, j=0 ???.?? 2,1
              ^^       -> skip logic
  i=5, j=1 ???.?? 2,1
                ^       -> match. dp[5+1+1][1] += 1

      dp[0]   dp[1]   dp[2]   dp[3]   dp[4]   dp[5]   dp[6]   dp[7]   dp[8]
i=0 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=1 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=2 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=3 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=4 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=5 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=6 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]
i=7 [ [0, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 0], [2, 1], [2, 2], [2, 2] ]

Answer = 2 * 2 = 4

--------------------------------------------------
Scenario 3: ??.#?.# 2,1
--------------------------------------------------

INSIGHT: max size for dp array should be length of springs, plus last group size, plus 1

i=0, j=0 ??.#?.#
         ^^      -> match - but we know it's not a match. Why?
                    How do we *not* count it in the end result?
i=1, j=0 ??.#?.#
          ^^
i=2, j=0 ??.#?.#
           ^^
i=3, j=0 ??.#?.#
            ^^     -> match.
  i=3, j=1 ??.#?.#
              ^    -> match, but we know it's not really a match.
                      This time, we know it won't work because we can look at remaining # after we remove our match.
                      ?.# still contains a # and this is our last group.
i=4, j=0 ??.#?.#
             ^^

      dp[0]   dp[1]   dp[2]   dp[3]   dp[4]   dp[5]   dp[6]   dp[7]   dp[8]
i=0 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0]
i=1 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0]
i=2 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0]
i=3 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 0], [2, 0]
i=4 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 0], [2, 0]
i=5 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 0], [2, 0]
i=6 [ [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 0], [2, 1]

Answer is wrongfully 2*1 = 2

--------------------------------------------------
Scenario 3: ??.#?.# 2,1
--------------------------------------------------

INSIGHT: max size for dp array should be length of springs, plus last group size, plus 1
POTENTIAL INSIGHT: add 1 up to minimum_remaining_strings
                   # minimum_remaining_strings = groups.iter().sum() + groups.iter().count() - 1;
3 + 2 - 1 = 4

i=0, j=0 ??.#?.#
         ^^      ->
i=1, j=0 ??.#?.#
          ^^
i=2, j=0 ??.#?.#
           ^^
i=3, j=0 ??.#?.#
            ^^     ->
  i=3, j=1 ??.#?.#
              ^    -> remaining # so invalid
i=4, j=0 ??.#?.#
             ^^
i=5, j=0 ??.#?.#
              ^^
i=6, j=0 ??.#?.#
               ^^

      dp[0]   dp[1]   dp[2]   dp[3]   dp[4]   dp[5]   dp[6]   dp[7]   dp[8]
i=0 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=1 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=2 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=3 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=4 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=5 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=6 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 1]

Answer is wrongfully 2*1 = 2

--------------------------------------------------
Scenario 4: ?#.??.# 2,1
--------------------------------------------------

INSIGHT: max size for dp array should be length of springs, plus last group size, plus 1
INSIGHT: if group is valid and contains #, don't move ahead checking different positions
e.g.: [?#].??.# 2,1 - don't check first group anymore
INSIGHT: If there is # remaining on last group, not valid.
INSIGHT: set a 1 for all indices up till a #

3 + 2 - 1 = 4

i=0, j=0 ?#.??.#
         ^^      ->

      dp[0]   dp[1]   dp[2]   dp[3]   dp[4]   dp[5]   dp[6]   dp[7]   dp[8]
i=0 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=1 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=2 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=3 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=4 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=5 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
i=6 [ [0, 0], [0, 0], [0, 0], [1, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 1]

Answer is wrongfully 2*1 = 2



POTENTIALLY SOLVED?
--------------------------------------------------
            012345678
Scenario 5: ???.??#.? 3,1
--------------------------------------------------
2 ways to do it

INSIGHT: max size for dp array should be length of springs, plus last group size, plus 1
INSIGHT: if group is valid and contains #, don't move ahead checking different positions
e.g.: [?#].??.# 2,1 - don't check first group anymore
INSIGHT: If there is # remaining on last group, not valid.
INSIGHT: set a 1 for all indices up to and including a #, starting from the length of group + 1

3 + 2 - 1 = 4

i=0, j=0 ?#.??.#
         ^^      ->

      dp[0]   dp[1]   dp[2]   dp[3]   dp[4]   dp[5]   dp[6]   dp[7]   dp[8]   dp[9]   dp[10] ]
i=0 [ [0, 0], [0, 0], [0, 0], [0, 0], [1, 0], [1, 0], [1, 0], [0, 0], [1, 1], [1, 2], [1, 2] ]


POTENTIALLY SOLVED?
--------------------------------------------------
            0123456
Scenario 5: ??.#.?? 1,1,1
--------------------------------------------------
4 ways to do it

INSIGHT: max size for dp array should be length of springs, plus last group size, plus 1
INSIGHT: if group is valid and contains #, don't move ahead checking different positions
e.g.: [?#].??.# 2,1 - don't check first group anymore
INSIGHT: If there is # remaining on last group, not valid.
INSIGHT: set a 1 for all indices up to and including a #, starting from the length of group + 1

      dp[0]      dp[1]      dp[2]      dp[3]      dp[4]      dp[5]      dp[6]      dp[7]      dp[8]     ]
i=0 [ [0, 0, 0], [0, 0, 0], [1, 0, 0], [2, 0, 0], [0, 0, 0], [0, 2, 2], [0, 2, 4], [0, 2, 4], [0, 2, 4] ]

POTENTIALLY SOLVED?
--------------------------------------------------
            01234567
Scenario 5: ??.??.?? 1,1,1
--------------------------------------------------
8 ways to do it

INSIGHT: max size for dp array should be length of springs, plus last group size, plus 1
INSIGHT: if group is valid and contains #, don't move ahead checking different positions
e.g.: [?#].??.# 2,1 - don't check first group anymore
INSIGHT: If there is # remaining on last group, not valid.
INSIGHT: set a 1 for all indices up to and including a #, starting from the length of group + 1
INSIGHT: if dp[i][j-] > 0 and current group valid: dp[i+group_len+1][j] += dp[i][j-1], up to and including a dp[i] with a #

      dp[0]      dp[1]      dp[2]      dp[3]      dp[4]      dp[5]      dp[6]      dp[7]      dp[8]       dp[9]     ]
    [ [0, 0, 0], [0, 0, 0], [2, 0, 0], [2, 0, 0], [2, 0, 0], [2, 2, 0], [2, 4, 0], [2, 4, 0], [2, 4, 4],  [2, 4, 8] ]

